#!/bin/bash
set -e

echo "=== نصب پنل مانیتورینگ لورنا PRO (Ubuntu 22.04+) ==="
echo "1) نصب و راه‌اندازی پنل"
echo "2) حذف پنل"
read -p "انتخاب (1 یا 2): " CHOICE

APP_DIR="/opt/network_monitor"
VENV_DIR="$APP_DIR/venv"
APP_PORT=5000
LICENSE_FILE="$APP_DIR/license.key"
LICENSE_VALUE="lorna"

if [ "$CHOICE" == "1" ]; then
    echo "[*] نصب بسته‌های سیستمی..."
    apt update
    apt install -y python3 python3-venv python3-pip curl lm-sensors jq

    echo "[*] ایجاد پوشه برنامه..."
    mkdir -p "$APP_DIR"
    echo "$LICENSE_VALUE" > "$LICENSE_FILE"
    chmod 600 "$LICENSE_FILE"

    echo "[*] ساخت محیط مجازی پایتون..."
    python3 -m venv "$VENV_DIR"
    source "$VENV_DIR/bin/activate"

    echo "[*] به‌روزرسانی pip و نصب پکیج‌های مورد نیاز..."
    pip install --upgrade pip
    pip install flask psutil requests

    echo "[*] ایجاد فایل برنامه Flask..."
    cat > "$APP_DIR/app.py" <<'EOF'
import os
import time
import threading
import platform
import socket

from flask import Flask, render_template_string, request, redirect, url_for, session, jsonify
import psutil
import requests

app = Flask(__name__)
app.secret_key = os.environ.get("LORNA_SECRET", "super_secret_key_lorna_change_me")

USERNAME = "admin"
PASSWORD = "admin123"
LICENSE_FILE = "/opt/network_monitor/license.key"

prev_net = {'bytes_sent': None, 'bytes_recv': None, 'time': None}
net_lock = threading.Lock()

cumulative_data = {
    'internal_upload_bytes': 0,
    'internal_download_bytes': 0,
}

def verify_license(license_key):
    try:
        if os.path.exists(LICENSE_FILE):
            with open(LICENSE_FILE, 'r') as f:
                stored = f.read().strip()
            return (license_key or "").strip() == stored
        return (license_key or "").strip() == "lorna"
    except Exception:
        return False

def get_network_io():
    counters = psutil.net_io_counters()
    return counters.bytes_sent, counters.bytes_recv

def get_network_speed_mb():
    with net_lock:
        cur_sent, cur_recv = get_network_io()
        now = time.time()

        if prev_net['time'] is None:
            prev_net['bytes_sent'] = cur_sent
            prev_net['bytes_recv'] = cur_recv
            prev_net['time'] = now
            return 0.0, 0.0

        dt = now - prev_net['time']
        if dt <= 0:
            return 0.0, 0.0

        delta_sent = cur_sent - prev_net['bytes_sent']
        delta_recv = cur_recv - prev_net['bytes_recv']

        prev_net['bytes_sent'] = cur_sent
        prev_net['bytes_recv'] = cur_recv
        prev_net['time'] = now

        up_mb = delta_sent / (1024 * 1024) / dt
        down_mb = delta_recv / (1024 * 1024) / dt

        cumulative_data['internal_upload_bytes'] += max(delta_sent, 0)
        cumulative_data['internal_download_bytes'] += max(delta_recv, 0)

        return round(max(up_mb, 0), 3), round(max(down_mb, 0), 3)

def get_external_network_usage():
    try:
        r = requests.get("https://ipinfo.io/json", timeout=3)
        data = r.json()
        ip = data.get("ip", "نامعلوم")
        country = data.get("country", "نامعلوم")
        return ip, country
    except Exception:
        return "نامعلوم", "نامعلوم"

def get_cpu_temp():
    try:
        if hasattr(psutil, "sensors_temperatures"):
            temps = psutil.sensors_temperatures(fahrenheit=False) or {}
            for key in ("coretemp", "k10temp", "acpitz", "cpu_thermal"):
                if key in temps and temps[key]:
                    return max([t.current for t in temps[key] if getattr(t, "current", None) is not None])
            for arr in temps.values():
                if arr:
                    return max([t.current for t in arr if getattr(t, "current", None) is not None])
    except Exception:
        pass
    return None

def get_top_processes(limit=10):
    procs = []
    for p in psutil.process_iter(['pid','name','username','cpu_percent','memory_percent']):
        try:
            info = p.info
            procs.append({
                'pid': info.get('pid'),
                'name': (info.get('name') or '')[:40],
                'user': (info.get('username') or '')[:20],
                'cpu': round(info.get('cpu_percent') or 0.0, 2),
                'mem': round(info.get('memory_percent') or 0.0, 2),
            })
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue
    top_cpu = sorted(procs, key=lambda x: x['cpu'], reverse=True)[:limit]
    top_mem = sorted(procs, key=lambda x: x['mem'], reverse=True)[:limit]
    return top_cpu, top_mem

# (قرار دادن کد html login_page و dashboard_page اینجا، همانند کد اصلی که فرستادید)

login_page = """<html lang="fa"><head><meta charset="UTF-8"><title>ورود | لورنا PRO</title>...</head><body>... (همان کد بالا)</body></html>"""
dashboard_page = """<html lang="fa" data-theme="dark"><head>... (همان کد بالا) ...</head><body>...</body></html>"""

from flask import render_template_string

@app.route('/', methods=['GET', 'POST'])
def login():
    if session.get("logged_in"):
        return redirect(url_for("dashboard"))

    error = None
    if request.method == 'POST':
        user = request.form.get("username", "")
        passwd = request.form.get("password", "")
        license_key = request.form.get("license", "")

        if user == USERNAME and passwd == PASSWORD and verify_license(license_key):
            session["logged_in"] = True
            return redirect(url_for("dashboard"))
        else:
            error = "نام کاربری، رمز عبور یا لایسنس اشتباه است."

    return render_template_string(login_page, error=error)

@app.route('/dashboard')
def dashboard():
    if not session.get("logged_in"):
        return redirect(url_for("login"))

    hostname = socket.gethostname()
    platform_str = platform.platform()
    cpu_count = psutil.cpu_count()
    cpu_temp = get_cpu_temp() or "نامعلوم"

    uptime_seconds = time.time() - psutil.boot_time()
    uptime_str = time.strftime("%H:%M:%S", time.gmtime(uptime_seconds))

    external_ip, external_country = get_external_network_usage()

    return render_template_string(dashboard_page,
                                  hostname=hostname,
                                  platform=platform_str,
                                  cpu_count=cpu_count,
                                  cpu_temp=cpu_temp,
                                  uptime=uptime_str,
                                  external_ip=external_ip,
                                  external_country=external_country)

@app.route('/api/stats')
def api_stats():
    if not session.get("logged_in"):
        return jsonify({"error": "unauthorized"}), 401

    cpu_percent = psutil.cpu_percent(interval=0.2)
    ram_percent = psutil.virtual_memory().percent

    net_up, net_down = get_network_speed_mb()
    cumu_up = cumulative_data['internal_upload_bytes']
    cumu_down = cumulative_data['internal_download_bytes']

    top_cpu, top_mem = get_top_processes(limit=10)

    return jsonify({
        "cpu_percent": cpu_percent,
        "ram_percent": ram_percent,
        "net_upload": net_up,
        "net_download": net_down,
        "cumu_upload_bytes": cumu_up,
        "cumu_download_bytes": cumu_down,
        "top_cpu": top_cpu,
        "top_mem": top_mem,
    })

@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('login'))

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
EOF

    echo "[*] تنظیم دسترسی‌ها..."
    chmod 700 "$APP_DIR/app.py"

    echo "[*] ایجاد سرویس systemd"
    cat > /etc/systemd/system/lorna-monitor.service <<EOF
[Unit]
Description=Lorna PRO Network Monitor
After=network.target

[Service]
User=root
WorkingDirectory=$APP_DIR
ExecStart=$VENV_DIR/bin/python3 $APP_DIR/app.py
Restart=always
RestartSec=5
Environment=PYTHONUNBUFFERED=1

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable lorna-monitor.service
    systemctl restart lorna-monitor.service

    echo "[+] نصب کامل شد."
    echo "مرورگر را باز کنید و به آدرس http://localhost:$APP_PORT مراجعه کنید."
    echo "نام کاربری: admin"
    echo "رمز عبور: admin123"
    echo "کد لایسنس: lorna"

elif [ "$CHOICE" == "2" ]; then
    echo "[*] متوقف کردن سرویس..."
    systemctl stop lorna-monitor.service || true
    systemctl disable lorna-monitor.service || true

    echo "[*] حذف فایل‌ها و دایرکتوری‌ها..."
    rm -rf "$APP_DIR"
    rm -f /etc/systemd/system/lorna-monitor.service
    systemctl daemon-reload

    echo "[+] حذف کامل انجام شد."
else
    echo "انتخاب نامعتبر."
fi
